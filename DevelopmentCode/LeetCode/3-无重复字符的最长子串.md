# 无重复字符的最长子串

## 题目

​	给定一个字符串 `s` ，请找出其中**不含有重复字符**的**最长子串**的长度。

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

**提示：**

- `0 <= s.length <= 5 * 104`
- `s` 由英文字母、数字、符号和空格组成

## 代码

```c
#include <stdio.h>

int lengthOfLongestSubstring(char *s) {
    int charIndex[128] = {0}; // 用于存储每个字符上一次出现的位置
    int maxLength = 0;
    int start = 0;

    for (int end = 0; s[end] != '\0'; ++end) {
        char currentChar = s[end];
        // 更新 start，如果当前字符之前已经出现过且位置大于等于当前窗口的起点
        if (charIndex[currentChar] > start) {
            start = charIndex[currentChar];
        }
        // 记录当前字符出现的位置+1（因为我们要确保下次处理的是不重复子串）
        charIndex[currentChar] = end + 1;
        // 计算当前窗口的长度，并更新最大长度
        int currentLength = end - start + 1;
        if (currentLength > maxLength) {
            maxLength = currentLength;
        }
    }

    return maxLength;
}

int main() {
    char s1[] = "abcabcbb";
    char s2[] = "bbbbb";
    char s3[] = "pwwkew";

    printf("示例 1: %d\n", lengthOfLongestSubstring(s1)); // 输出 3
    printf("示例 2: %d\n", lengthOfLongestSubstring(s2)); // 输出 1
    printf("示例 3: %d\n", lengthOfLongestSubstring(s3)); // 输出 3

    return 0;
}

```

## 解析

### 思路：

​	我们需要找到一个字符串中的最长子串，其中的字符不能重复。需要注意的是**子串**是字符串中连续的一部分，例如`abcabcbb`，`abc`是子串，长度为3。 `b`也是一个子串，长度为1。因此要解决这个问题，我们需要使用到一个叫**滑动窗口**的技巧。本质是利用两个指针`start`、`end`。由`end`滑动索引，`start`更新起始位置。这种方法的核心思想是维护一个可变大小的窗口，窗口内的字符是当前考虑的无重复子串。当遇到重复字符时，更新`start`的位置，将窗口缩小，直到不再有重复字符。

### 步骤：

**定义指针**：使用两个指针 `start` 和 `end` 来表示当前的滑动窗口的边界：

- `start` 指向当前窗口的起始位置。
- `end` 指向当前窗口的结束位置（遍历字符串时不断向前移动）。

**使用哈希表或数组**：用一个数组或哈希表来记录每个字符最后出现的位置。我们可以利用 ASCII 码字符集的大小（通常为 128）来创建一个大小为 128 的数组，数组的索引表示字符的 ASCII 值，值表示该字符上一次出现的位置。

**遍历字符串**：通过 `end` 指针遍历字符串中的每个字符：

- 检查当前字符是否在之前出现过：
  - 如果当前字符在窗口内（即它的上次出现位置大于或等于 `start`），则更新 `start` 到该字符上一次出现的后一个位置。
- 更新字符在 `charIndex` 数组中的最后出现位置。
- 计算当前窗口的长度（`end - start + 1`），并更新记录的最大长度。

**返回结果**：在遍历结束后，返回记录的最大长度。

### 数组`int charIndex[128]`

**这个数组必须拉出来单独说。**

​	前面分析过，可以用哈希表来记录每个字符最后出现的位置。即出现过的字符为`key`，其对应的位置为`value`，如果哈希表中有某个字符的数据即表示该字符出现过。