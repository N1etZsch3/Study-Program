# 泛型

+ **定义类、接口、方法时，同时声明了一个或者多个类型变量（如：`<E>`），称为泛型类、泛系接口、泛型方法。统称为泛型。**
+ **泛型提供了在编译阶段约束所能操作的数据类型，并自动进行检查的能力。这样可以避免强制类型转换，及其可能出现的异常。**

+ **泛型的本质：把具体的数据类型作为参数传给类型变量。**



## 泛型标记符

+ **E** - Element，元素
+ **T** - Type， Java类
+ **K** - Key，键
+ **V** - Value，值
+ **N** - Number 数值
+ **?** - 通配符。

> **`?`** 通配符可以在**使用泛型**的时候代表一切类型。



## 泛型类

**定义泛型类的语法为：**

```java
修饰符 class 类名 <类型变量, 类型变量...>{}
```

**示例代码**

```java
package com.n1etzsch3.genericsdemo1;

import java.util.ArrayList;

// 自定义泛型类 MyArrayList
// 用装饰器模式实现一个简单的 ArrayList 功能
public class MyArrayList <E> {

    ArrayList<E> list = new ArrayList<>();

    public void add(E element) {
        list.add(element);
    }

    public void remove(E element) {
        list.remove(element);
    }

    public void modify(int index, E element) {
        if (index >= 0 && index < list.size()) {
            list.set(index, element);
        } else {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + list.size());
        }
    }

    public void query(E element) {
        if (list.contains(element)) {
            System.out.println("Element found: " + element);
        } else {
            System.out.println("Element not found: " + element);
        }
    }

    public void printList() {
        System.out.println("List contents: " + list.toString());
    }
}
```

**调用**

```java
package com.n1etzsch3.genericsdemo1;

public class Test {

    public static void main(String[] args) {
        MyArrayList<String> myList = new MyArrayList<>();  // 字符串泛型
        // 添加元素
        myList.add("Hello");
        myList.add("World");
        myList.add("Generics");

        // 打印列表内容
        myList.printList();

        // 查询元素
        myList.query("World");

        // 修改元素
        myList.modify(1, "Java");
        myList.printList();

        // 删除元素
        myList.remove("Hello");
        myList.printList();

        MyArrayList<Integer> intList = new MyArrayList<>();		// 整型泛型

        // 添加整数元素
        intList.add(1);
        intList.add(2);
        intList.add(3);

        // 打印整数列表内容
        intList.printList();

        // 查询整数元素
        intList.query(2);

        // 修改整数元素
        intList.modify(1, 20);
        intList.printList();

        // 删除整数元素
        intList.remove(1);
        intList.printList();
    }

}
```

>  **泛型的原理就是，在有`E`这种泛型标识符的地方，统一替换为指定的数据类型。即数据类型参数化。**



## 泛型接口

```java
package com.n1etzsch3.genericsdemo2;

public interface AnimalOperator <T> {
    // 添加动物
    void add(T animal);
    // 删除动物
    void remove(T animal);
    // 修改动物
    void modify(int index, T animal);
    // 查询动物
    void query(T animal);
    // 打印动物列表
    void printList();
}
```

```java
package com.n1etzsch3.genericsdemo2;

public class Cat implements AnimalOperator<Cat> {

    private final String name;

    public Cat(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public void add(Cat animal) {
        System.out.println("Adding cat: " + animal.getName());
    }

    @Override
    public void remove(Cat animal) {
        System.out.println("Removing cat: " + animal.getName());
    }

    @Override
    public void modify(int index, Cat animal) {
        System.out.println("Modifying cat at index " + index + " to: " + animal.getName());
    }

    @Override
    public void query(Cat animal) {
        System.out.println("Querying cat: " + animal.getName());
    }

    @Override
    public void printList() {
        System.out.println("Printing cat list...");
    }
}

```

```java
package com.n1etzsch3.genericsdemo2;

public class Dog implements AnimalOperator<Dog>{

    private final String name;

    public Dog(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public void add(Dog animal) {
        System.out.println("Adding dog: " + animal.getName());
    }

    @Override
    public void remove(Dog animal) {
        System.out.println("Removing dog: " + animal.getName());
    }

    @Override
    public void modify(int index, Dog animal) {
        System.out.println("Modifying dog at index " + index + " to: " + animal.getName());
    }

    @Override
    public void query(Dog animal) {
        System.out.println("Querying dog: " + animal.getName());
    }

    @Override
    public void printList() {
        System.out.println("Printing dog list...");
    }
}
```



## 泛型方法

**定义泛型方法可以自适应数据类型，不用强制转换。**

**示例代码：**

```java
package com.n1etzsch3.genericsdemo3;

public class Test {
    public static void main(String[] args) {
        String[] stringArray = {"Hello", "World", "Generics"};
        Integer[] intArray = {1, 2, 3, 4, 5};
        Double[] doubleArray = {1.1, 2.2, 3.3};

        printArray(stringArray);
        printArray(intArray);
        printArray(doubleArray);

    }

    public static <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.print(element + " ");
        }
        System.out.println();
    }
}
```



## 通配符 `?` 与上下限

**通配符用于在使用时匹配所有类型的数据。与其他标识符不同的是，其他标识符在定义泛型时使用，通配符在使用泛型时使用。**

```java
package com.n1etzsch3.genericsdemo3;

import java.util.ArrayList;

public class Test {
    public static void main(String[] args) {
        ArrayList<XiaomiCar> xiaomiCars = new ArrayList<>();
        xiaomiCars.add(new XiaomiCar());
        xiaomiCars.add(new XiaomiCar());
        xiaomiCars.add(new XiaomiCar());
        transitCar(xiaomiCars);

        ArrayList<TeslaCar> teslaCars = new ArrayList<>();
        teslaCars.add(new TeslaCar());
        teslaCars.add(new TeslaCar());
        teslaCars.add(new TeslaCar());
        teslaCars.add(new TeslaCar());
        transitCar(teslaCars);

        ArrayList<VolvoCar> volvoCars = new ArrayList<>();
        volvoCars.add(new VolvoCar());
        volvoCars.add(new VolvoCar());
        volvoCars.add(new VolvoCar());
        volvoCars.add(new VolvoCar());
        volvoCars.add(new VolvoCar());
        transitCar(volvoCars);
    }

    public static void transitCar(ArrayList<? extends Car> cars){
        System.out.println("Transiting cars: " + cars.size());
    }
}

class Car{}

class XiaomiCar extends Car{}

class TeslaCar extends Car{}

class VolvoCar extends Car{}
```

**上下限是为了防止用户使用其他非法类，匹配通配符。**

+ **上限：**`? extends Car`，意思是`?`能匹配的必须是Car及其**子类**。
+ **下限：**`? super Car`，意思是`?`能匹配的必须是Car及其**父类**



## 泛型支持的类型

<font color=red>泛型不支持**基本数据类型**，只支持**引用数据类型（对象）**</font>

### 包装类

要定义基本数据类型的泛型，就必须把基本数据类型包装成引用数据类型，也叫**包装类**。

#### **基本数据类型对应的包装类：**

| **基本数据类型** |             **包装类**             |
| :--------------: | :--------------------------------: |
|      `byte`      |               `Byte`               |
|     `short`      |              `Short`               |
|      `int`       |  <font color=red>`Integer`</font>  |
|      `long`      |               `Long`               |
|     `float`      |              `Float`               |
|     `double`     |              `Double`              |
|      `char`      | <font color=red>`Character`</font> |
|    `boolean`     |             `Boolean`              |

#### 手动包装

```java
Integer it = Integer.valueof(100);
```

#### 自动包装

```java
Integer it1 = 100;	// 	自动装箱：可以直接为包装类赋值，自动转换为包装类。
int i = it1;		// 自动拆箱：包装类可以自动转换为基本数据类型。
```

#### 包装类具备的功能

+ 可以把基本数据类型转换为字符串类型。

```java
int j = 23;
String rs = Integer.toString(j);
System.out.println(j + 1);
```

输出：231。

+ 可以把字符串类型的数值转换成数值本身对应的真实数据类型。

```java
String str = "98";
int i1 = Integer.valueof(str);
// 或 int i1 = Integer.parseInt(str);
System.out.println(i1+1);
```

输出：99。